from typing import (
    Any,
    IO,
    MutableMapping,
    MutableSequence,
    Optional,
    Pattern,
    Sequence,
    Set,
    Tuple,
)

from xdg import BaseDirectory as BaseDirectory

FREE_NS: str
types: MutableMapping[Tuple[str, str], MIMEType]
exts: Optional[Any]
globs: Optional[GlobDB]
literals: Optional[Any]
magic: Optional[MagicDB]
PY3: bool

def lookup(media: str, subtype: Optional[str] = ...) -> MIMEtype: ...

class MIMEtype:
    def __new__(cls, media: str, subtype: Optional[str] = ...) -> MIMEtype: ...
    def get_comment(self) -> str: ...
    def canonical(self) -> MIMEtype: ...
    def inherits_from(self) -> Set[MIMEtype]: ...
    def __hash__(self) -> integer: ...

class UnknownMagicRuleFormat(ValueError): ...
class DiscardMagicRules(Exception): ...

class MagicRule:
    also: Optional[Pattern[str]]
    start: int
    value: bytes
    mask: bytes
    word: bytes
    range: int
    def __init__(
        self, start: int, value: bytes, mask: bytes, word: bytes, range: int
    ) -> None: ...
    rule_ending_re: Pattern[str]
    @classmethod
    def from_file(cls, f: IO[bytes]) -> Tuple[int, MagicRule]: ...
    def maxlen(self) -> int: ...
    def match(self, buffer: bytes) -> bool: ...
    def match0(self, buffer: bytes) -> bool: ...

RuleTree = Sequence[Tuple[MagicRule, "RuleTree"]]

class MagicMatchAny:
    rules: Sequence[MagicRule]
    def __init__(self, rules: Sequence[MagicRule]) -> None: ...
    def match(self, buffer: bytes) -> bool: ...
    def maxlen(self) -> int: ...
    @classmethod
    def from_file(cls, f: str) -> MagicMatchAny: ...
    @classmethod
    def from_rule_tree(cls, tree: RuleTree) -> MagicMatchAny: ...

class MagicDB:
    bytype: MutableMapping[MIMEtype, Sequence[Tuple[int, MagicMatchAny]]]
    def __init__(self) -> None: ...
    def merge_file(self, fname: str) -> None: ...
    alltypes: MutableSequence[Tuple[int, MIMEtype, MagicMatchAny]]
    maxlen: int
    def finalise(self) -> None: ...
    def match_data(
        self,
        data: bytes,
        max_pri: int = ...,
        min_pri: int = ...,
        possible: Optional[Sequence[MIMEtype]] = ...,
    ) -> MIMEtype: ...
    def match(
        self,
        path: str,
        max_pri: int = ...,
        min_pri: int = ...,
        possible: Optional[Sequence[MIMEtype]] = ...,
    ) -> MIMEtype: ...

class GlobDB:
    allglobs: MutableMapping[MIMEtype, Set[Tuple[int, str, Tuple[str, ...]]]]
    def __init__(self) -> None: ...
    def merge_file(self, path: str) -> None: ...
    exts: MutableMapping[str, Sequence[Tuple[MIMEtype, int]]]
    cased_exts: MutableMapping[str, Sequence[Tuple[MIMEtype, int]]]
    globs: MutableSequence[Tuple[Pattern[str], MIMEtype, int]]
    literals: MutableMapping[str, Sequence[Tuple[MIMEtype, int]]]
    cased_literals: MutableMapping[str, Sequence[Tuple[MIMEtype, int]]]
    def finalise(self) -> None: ...
    def first_match(self, path: str) -> Optional[Tuple[MIMEtype, int]]: ...
    def all_matches(self, path: str) -> Sequence[Tuple[MIMEtype, int]]: ...

text: MIMEtype
octet_stream: MIMEtype
inode_block: MIMEtype
inode_char: MIMEtype
inode_dir: MIMEtype
inode_fifo: MIMEtype
inode_socket: MIMEtype
inode_symlink: MIMEtype
inode_door: MIMEtype
app_exe: MIMEtype

def update_cache() -> None: ...
def get_type_by_name(path: str) -> Optional[Tuple[MIMEtype, int]]: ...
def get_type_by_contents(
    path: str, max_pri: int = ..., min_pri: int = ...
) -> MIMEtype: ...
def get_type_by_data(
    data: bytes, max_pri: int = ..., min_pri: int = ...
) -> MIMEtype: ...
def get_type(
    path: str, follow: bool = ..., name_pri: int = ...
) -> Tuple[MIMEtype, int] | MIMEtype: ...
def get_type2(path: str, follow: bool = ...) -> Tuple[MIMEtype, int] | MIMEtype: ...
def is_text_file(path: str) -> bool: ...
def get_extensions(mimetype: MIMEtype) -> Set[str]: ...
def install_mime_info(application: str, package_file: str) -> None: ...
